<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Dns_certify (dns-certify.Dns_certify)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">dns-certify</a> &#x00BB; Dns_certify</nav><h1>Module <code>Dns_certify</code></h1></header><dl><dt class="spec value" id="val-signing_request"><a href="#val-signing_request" class="anchor"></a><code><span class="keyword">val</span> signing_request : <span><span>[ `host ]</span> Domain_name.t</span> <span>&#45;&gt;</span> <span>?&#8288;more_hostnames:<span><span><span>[ `raw ]</span> Domain_name.t</span> list</span></span> <span>&#45;&gt;</span> X509.Private_key.t <span>&#45;&gt;</span> X509.Signing_request.t</code></dt><dd><p><code>signing_request name ~more_hostnames key</code> creates a X509 signing request where <code>name</code> will be the common name in its subject, and if <code>more_hostnames</code> is provided and non-empty, <code>name :: more_hostnames</code> will be the value of a subjectAlternativeName extension.</p></dd></dl><dl><dt class="spec value" id="val-letsencrypt_name"><a href="#val-letsencrypt_name" class="anchor"></a><code><span class="keyword">val</span> letsencrypt_name : <span><span class="type-var">'a</span> Domain_name.t</span> <span>&#45;&gt;</span> <span><span>(<span><span>[ `raw ]</span> Domain_name.t</span>, <span>[&gt; <span>`Msg of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>letsencrypt_name host</code> is the service name at which we store let's encrypt certificates for the <code>host</code>.</p></dd></dl><dl><dt class="spec value" id="val-is_csr"><a href="#val-is_csr" class="anchor"></a><code><span class="keyword">val</span> is_csr : <a href="../../dns/Dns/Tlsa/index.html#type-t">Dns.Tlsa.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_csr tlsa</code> is true if <code>tlsa</code> is a certificate signing request (cert_usage is Domain_issued_certificate, selector is Private, and matching_type is No_hash).</p></dd></dl><dl><dt class="spec value" id="val-csr"><a href="#val-csr" class="anchor"></a><code><span class="keyword">val</span> csr : X509.Signing_request.t <span>&#45;&gt;</span> <a href="../../dns/Dns/Tlsa/index.html#type-t">Dns.Tlsa.t</a></code></dt><dd><p><code>csr req</code> is the signing request <code>req</code> encoded as TLSA record.</p></dd></dl><dl><dt class="spec value" id="val-is_certificate"><a href="#val-is_certificate" class="anchor"></a><code><span class="keyword">val</span> is_certificate : <a href="../../dns/Dns/Tlsa/index.html#type-t">Dns.Tlsa.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_certificate tlsa</code> is true if <code>tlsa</code> is a certificate (cert_usage is Domain_issued_certificate, selector is Full_certificate, and matching_type is No_hash).</p></dd></dl><dl><dt class="spec value" id="val-certificate"><a href="#val-certificate" class="anchor"></a><code><span class="keyword">val</span> certificate : X509.Certificate.t <span>&#45;&gt;</span> <a href="../../dns/Dns/Tlsa/index.html#type-t">Dns.Tlsa.t</a></code></dt><dd><p><code>certificate crt</code> is the certificate <code>crt</code> encoded as TLSA record.</p></dd></dl><dl><dt class="spec value" id="val-is_ca_certificate"><a href="#val-is_ca_certificate" class="anchor"></a><code><span class="keyword">val</span> is_ca_certificate : <a href="../../dns/Dns/Tlsa/index.html#type-t">Dns.Tlsa.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_ca_certificate tlsa</code> is true if <code>tlsa</code> is a CA certificate (cert_usage is CA_constraint, selector is Full_certificate, and matching_type is No_hash).</p></dd></dl><dl><dt class="spec value" id="val-ca_certificate"><a href="#val-ca_certificate" class="anchor"></a><code><span class="keyword">val</span> ca_certificate : Cstruct.t <span>&#45;&gt;</span> <a href="../../dns/Dns/Tlsa/index.html#type-t">Dns.Tlsa.t</a></code></dt><dd><p><code>ca_certificate data</code> is the CA certificate <code>data</code> encoded as TLSA record.</p></dd></dl><dl><dt class="spec value" id="val-is_name"><a href="#val-is_name" class="anchor"></a><code><span class="keyword">val</span> is_name : <span><span class="type-var">'a</span> Domain_name.t</span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_name domain_name</code> is true if it contains the prefix used in this library (&quot;_letsencrypt._tcp&quot;).</p></dd></dl><dl><dt class="spec type" id="type-u_err"><a href="#type-u_err" class="anchor"></a><code><span class="keyword">type</span> u_err</code> = <code>[ </code><table class="variant"><tr id="type-u_err.Tsig" class="anchored"><td class="def constructor"><a href="#type-u_err.Tsig" class="anchor"></a><code>| </code><code>`Tsig <span class="keyword">of</span> <a href="../../dns-tsig/Dns_tsig/index.html#type-e">Dns_tsig.e</a></code></td></tr><tr id="type-u_err.Bad_reply" class="anchored"><td class="def constructor"><a href="#type-u_err.Bad_reply" class="anchor"></a><code>| </code><code>`Bad_reply <span class="keyword">of</span> <a href="../../dns/Dns/Packet/index.html#type-mismatch">Dns.Packet.mismatch</a> * <a href="../../dns/Dns/Packet/index.html#type-t">Dns.Packet.t</a></code></td></tr><tr id="type-u_err.Unexpected_reply" class="anchored"><td class="def constructor"><a href="#type-u_err.Unexpected_reply" class="anchor"></a><code>| </code><code>`Unexpected_reply <span class="keyword">of</span> <a href="../../dns/Dns/Packet/index.html#type-reply">Dns.Packet.reply</a></code></td></tr></table><code> ]</code></dt><dd><p>The type of update errors.</p></dd></dl><dl><dt class="spec value" id="val-pp_u_err"><a href="#val-pp_u_err" class="anchor"></a><code><span class="keyword">val</span> pp_u_err : <span><a href="index.html#type-u_err">u_err</a> Fmt.t</span></code></dt><dd><p><code>pp_u_err ppf u</code> pretty-prints <code>u</code> on <code>ppf</code>.</p></dd></dl><dl><dt class="spec value" id="val-nsupdate"><a href="#val-nsupdate" class="anchor"></a><code><span class="keyword">val</span> nsupdate : <span>(int <span>&#45;&gt;</span> Cstruct.t)</span> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> Ptime.t)</span> <span>&#45;&gt;</span> <span>host:<span><span>[ `host ]</span> Domain_name.t</span></span> <span>&#45;&gt;</span> <span>keyname:<span><span class="type-var">'b</span> Domain_name.t</span></span> <span>&#45;&gt;</span> <span>zone:<span><span>[ `host ]</span> Domain_name.t</span></span> <span>&#45;&gt;</span> <a href="../../dns/Dns/Dnskey/index.html#type-t">Dns.Dnskey.t</a> <span>&#45;&gt;</span> X509.Signing_request.t <span>&#45;&gt;</span> <span><span>(Cstruct.t * <span>(Cstruct.t <span>&#45;&gt;</span> <span><span>(unit, <span>[&gt; <a href="index.html#type-u_err">u_err</a> ]</span>)</span> Stdlib.result</span>)</span>, <span>[&gt; <span>`Msg of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>nsupdate rng now ~host ~keyname ~zone dnskey csr</code> is a buffer with a DNS update that removes all TLSA records from the given <code>host</code>, and adds a single TLSA record containing the certificate signing request. It also returns a function which decodes a given answer, checks it to be a valid reply, and returns either unit or an error. The outgoing packet is signed with the provided <code>dnskey</code>, the answer is checked to be signed by the same key. If the sign operation fails, <code>nsupdate</code> returns an error.</p></dd></dl><dl><dt class="spec type" id="type-q_err"><a href="#type-q_err" class="anchor"></a><code><span class="keyword">type</span> q_err</code> = <code>[ </code><table class="variant"><tr id="type-q_err.Decode" class="anchored"><td class="def constructor"><a href="#type-q_err.Decode" class="anchor"></a><code>| </code><code>`Decode <span class="keyword">of</span> <a href="../../dns/Dns/Packet/index.html#type-err">Dns.Packet.err</a></code></td></tr><tr id="type-q_err.Bad_reply" class="anchored"><td class="def constructor"><a href="#type-q_err.Bad_reply" class="anchor"></a><code>| </code><code>`Bad_reply <span class="keyword">of</span> <a href="../../dns/Dns/Packet/index.html#type-mismatch">Dns.Packet.mismatch</a> * <a href="../../dns/Dns/Packet/index.html#type-t">Dns.Packet.t</a></code></td></tr><tr id="type-q_err.Unexpected_reply" class="anchored"><td class="def constructor"><a href="#type-q_err.Unexpected_reply" class="anchor"></a><code>| </code><code>`Unexpected_reply <span class="keyword">of</span> <a href="../../dns/Dns/Packet/index.html#type-reply">Dns.Packet.reply</a></code></td></tr><tr id="type-q_err.No_tlsa" class="anchored"><td class="def constructor"><a href="#type-q_err.No_tlsa" class="anchor"></a><code>| </code><code>`No_tlsa</code></td></tr></table><code> ]</code></dt><dd><p>The type for query errors.</p></dd></dl><dl><dt class="spec value" id="val-pp_q_err"><a href="#val-pp_q_err" class="anchor"></a><code><span class="keyword">val</span> pp_q_err : <span><a href="index.html#type-q_err">q_err</a> Fmt.t</span></code></dt><dd><p><code>pp_q_err ppf q</code> pretty-prints <code>q</code> on <code>ppf</code>.</p></dd></dl><dl><dt class="spec value" id="val-cert_matches_csr"><a href="#val-cert_matches_csr" class="anchor"></a><code><span class="keyword">val</span> cert_matches_csr : <span>?&#8288;until:Ptime.t</span> <span>&#45;&gt;</span> Ptime.t <span>&#45;&gt;</span> X509.Signing_request.t <span>&#45;&gt;</span> X509.Certificate.t <span>&#45;&gt;</span> bool</code></dt><dd><p><code>cert_matches_csr ~until now csr cert</code> is <code>true</code> if <code>cert</code> matches the signing request <code>csr</code>, and is valid from <code>now</code> until <code>until</code> (defaults to <code>now</code>). The matching is <code>true</code> if the public key matches, and the set of hostnames in <code>csr</code> and <code>cert</code> are equal. A log message on the info level is emitted if the return value if <code>false</code>.</p></dd></dl><dl><dt class="spec value" id="val-query"><a href="#val-query" class="anchor"></a><code><span class="keyword">val</span> query : <span>(int <span>&#45;&gt;</span> Cstruct.t)</span> <span>&#45;&gt;</span> Ptime.t <span>&#45;&gt;</span> <span><span>[ `host ]</span> Domain_name.t</span> <span>&#45;&gt;</span> X509.Signing_request.t <span>&#45;&gt;</span> <span><span>(Cstruct.t * <span>(Cstruct.t <span>&#45;&gt;</span> <span><span>(X509.Certificate.t * <span>X509.Certificate.t list</span>, <span>[&gt; <a href="index.html#type-q_err">q_err</a> ]</span>)</span> Stdlib.result</span>)</span>, <span>[&gt; <span>`Msg of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>query rng now csr</code> is a <code>buffer</code> with a DNS TLSA query for the name of <code>csr</code>, and a function that decodes a given answer, either returning a X.509 certificate valid <code>now</code> and matching <code>csr</code>, and a CA chain, or an error.</p></dd></dl></div></body></html>